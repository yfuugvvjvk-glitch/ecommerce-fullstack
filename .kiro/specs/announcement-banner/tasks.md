# Implementation Plan: Announcement Banner

## Overview

This implementation plan breaks down the announcement banner feature into discrete coding tasks. The approach follows an incremental development strategy: backend first (data layer and API), then frontend components (display and admin interface), and finally integration and testing. Each task builds on previous work to ensure a working system at each checkpoint.

## Tasks

- [ ] 1. Initialize banner configuration in database
  - Create initialization script to set up default banner config in SiteConfig table
  - Add default values for all style properties
  - Set isActive to false by default
  - _Requirements: 2.5.1_

- [ ] 2. Implement backend API endpoints
  - [ ] 2.1 Create admin GET endpoint for banner configuration
    - Add route handler in `backend/src/routes/admin.routes.ts`
    - Use existing `siteConfigService.getConfig('announcement_banner')`
    - Add authentication and admin authorization middleware
    - Return default config if none exists
    - _Requirements: 2.2.1_
  - [ ] 2.2 Create admin PUT endpoint for banner updates
    - Add route handler in `backend/src/routes/admin.routes.ts`
    - Implement server-side validation (title length, description length, color format, font size ranges)
    - Use `siteConfigService.setConfig()` to persist changes
    - Trigger WebSocket broadcast for real-time updates
    - Return updated configuration
    - _Requirements: 2.2.2, 2.2.3, 2.2.4, 2.3.1-2.3.6, 2.4.1-2.4.6, 2.5.1, 2.5.3_
  - [ ]\* 2.3 Write property test for configuration round-trip
    - **Property 6: Configuration Round-Trip**
    - **Validates: Requirements 2.5.1**
  - [ ]\* 2.4 Write property test for active toggle preserves content
    - **Property 4: Active Toggle Preserves Content**
    - **Validates: Requirements 2.2.4**
  - [ ] 2.5 Create public GET endpoint for active banner
    - Add route handler in `backend/src/routes/public.routes.ts`
    - Fetch banner config from SiteConfig
    - Return null if isActive is false
    - Return null if both title and description are empty
    - Return full config otherwise
    - _Requirements: 2.1.2_
  - [ ]\* 2.6 Write unit tests for public endpoint logic
    - Test returns null when inactive
    - Test returns null when content is empty
    - Test returns config when active and has content
    - _Requirements: 2.1.2_

- [ ] 3. Checkpoint - Ensure backend tests pass
  - Ensure all tests pass, ask the user if questions arise.

- [ ] 4. Create frontend banner display component
  - [ ] 4.1 Implement AnnouncementBanner component
    - Create `frontend/components/AnnouncementBanner.tsx`
    - Accept config and onClose props
    - Render title and description with custom styles
    - Apply inline styles from config (colors, fonts, sizes, alignment)
    - Add close button with click handler
    - Implement responsive design with Tailwind classes
    - Add ARIA labels for accessibility
    - _Requirements: 2.1.1, 2.1.3, 2.1.4_
  - [ ]\* 4.2 Write property test for empty banner visibility
    - **Property 1: Empty Banner Visibility**
    - **Validates: Requirements 2.1.2**
  - [ ]\* 4.3 Write property test for close button functionality
    - **Property 2: Close Button Functionality**
    - **Validates: Requirements 2.1.4**
  - [ ]\* 4.4 Write unit tests for banner component
    - Test renders with provided config
    - Test applies custom styles correctly
    - Test close button calls onClose handler
    - Test accessibility attributes present
    - _Requirements: 2.1.1, 2.1.4_

- [ ] 5. Integrate banner into dashboard page
  - [ ] 5.1 Add banner state and API call to dashboard
    - Update `frontend/app/(dashboard)/dashboard/page.tsx`
    - Add state for bannerConfig and showBanner
    - Fetch banner config from `/api/announcement-banner` on mount
    - Handle fetch errors gracefully (fail silently)
    - _Requirements: 2.1.1, 2.1.2_
  - [ ] 5.2 Render banner above carousel
    - Add conditional rendering of AnnouncementBanner component
    - Position above carousel when no category selected
    - Pass config and onClose handler
    - _Requirements: 2.1.1_
  - [ ] 5.3 Implement real-time updates via WebSocket
    - Subscribe to 'config_updated' events
    - Update bannerConfig when announcement_banner key changes
    - Use existing WebSocket infrastructure
    - _Requirements: 2.5.3_

- [ ] 6. Checkpoint - Verify banner displays correctly
  - Ensure all tests pass, ask the user if questions arise.

- [ ] 7. Create admin banner editor components
  - [ ] 7.1 Implement BannerPreview component
    - Create `frontend/components/admin/BannerPreview.tsx`
    - Accept config prop
    - Render banner exactly as it appears on dashboard
    - Update in real-time as config changes
    - _Requirements: 2.6.1, 2.6.2_
  - [ ]\* 7.2 Write property test for preview reflects form state
    - **Property 8: Preview Reflects Form State**
    - **Validates: Requirements 2.6.1, 2.6.2**
  - [ ] 7.3 Implement AdminBannerEditor component
    - Create `frontend/components/admin/AdminBannerEditor.tsx`
    - Add form with controlled inputs for title and description
    - Add toggle for isActive
    - Add color pickers for text and background colors (title and description)
    - Add font size sliders (12-48px for title, 12-32px for description)
    - Add font family dropdowns
    - Add font weight selectors
    - Add text alignment buttons
    - Implement client-side validation
    - Add save button with loading state
    - Display validation errors
    - _Requirements: 2.2.1, 2.2.2, 2.2.3, 2.2.4, 2.3.1-2.3.6, 2.4.1-2.4.6_
  - [ ] 7.4 Integrate preview into editor
    - Add BannerPreview component to AdminBannerEditor
    - Pass current form state to preview
    - Update preview in real-time as form changes
    - _Requirements: 2.6.1, 2.6.2_
  - [ ]\* 7.5 Write unit tests for admin editor
    - Test loads current config on mount
    - Test validates title length (max 200)
    - Test validates description length (max 1000)
    - Test validates color format
    - Test validates font size ranges
    - Test updates preview on form change
    - _Requirements: 2.2.2, 2.2.3, 2.3.3, 2.4.3_
  - [ ]\* 7.6 Write property test for content update persistence
    - **Property 3: Content Update Persistence**
    - **Validates: Requirements 2.2.2, 2.2.3**
  - [ ]\* 7.7 Write property test for style configuration persistence
    - **Property 5: Style Configuration Persistence**
    - **Validates: Requirements 2.3.1-2.3.6, 2.4.1-2.4.6**

- [ ] 8. Create admin banner page and navigation
  - [ ] 8.1 Create admin banner page
    - Create `frontend/app/(dashboard)/admin/banner/page.tsx`
    - Import and render AdminBannerEditor component
    - Add page title and description
    - Wrap in admin layout
    - _Requirements: 2.2.1_
  - [ ] 8.2 Add navigation link in admin sidebar
    - Update admin navigation to include "Banner AnunÈ›uri" link
    - Add appropriate icon (ðŸ“¢)
    - Link to `/admin/banner`
    - _Requirements: 2.2.1_

- [ ] 9. Implement validation and error handling
  - [ ] 9.1 Add client-side validation function
    - Create validation function in AdminBannerEditor
    - Validate title length (max 200 characters)
    - Validate description length (max 1000 characters)
    - Validate hex color format (#RRGGBB or #RRGGBBAA)
    - Validate font size ranges (12-48 for title, 12-32 for description)
    - Return error messages in Romanian
    - _Requirements: 2.2.2, 2.2.3, 2.3.3, 2.4.3_
  - [ ] 9.2 Add server-side validation in PUT endpoint
    - Validate all input fields before saving
    - Return 400 error with validation messages
    - Prevent invalid data from being saved
    - _Requirements: 2.2.2, 2.2.3, 2.3.1-2.3.6, 2.4.1-2.4.6_
  - [ ] 9.3 Add error handling in components
    - Handle API errors in AdminBannerEditor
    - Display error messages using toast notifications
    - Handle fetch errors in dashboard (fail silently)
    - Add try-catch blocks around API calls
    - _Requirements: 2.2.1, 2.2.2, 2.2.3_

- [ ] 10. Add accessibility features
  - [ ] 10.1 Add ARIA labels to banner component
    - Add role="banner" to container
    - Add aria-label to close button
    - Add aria-hidden to decorative icons
    - Ensure proper heading hierarchy
    - _Requirements: 2.1.1, 2.1.4_
  - [ ] 10.2 Implement keyboard navigation
    - Add keyboard support for close button (Enter, Space)
    - Ensure tab order is logical
    - Add focus styles for interactive elements
    - _Requirements: 2.1.4_
  - [ ] 10.3 Add color contrast validation
    - Create contrast ratio calculation function
    - Warn admin if contrast is insufficient (< 4.5:1)
    - Display warning in admin editor
    - _Requirements: 2.3.1, 2.3.2, 2.4.1, 2.4.2_

- [ ] 11. Optimize performance
  - [ ] 11.1 Add caching to public endpoint
    - Implement in-memory cache for banner config
    - Set cache TTL to 1 minute
    - Invalidate cache on update
    - _Requirements: 2.5.1_
  - [ ] 11.2 Memoize banner component
    - Use React.memo to prevent unnecessary re-renders
    - Add custom comparison function for config prop
    - _Requirements: 2.1.1_
  - [ ] 11.3 Debounce preview updates
    - Add debounce to preview updates in admin editor
    - Set debounce delay to 300ms
    - Prevent excessive re-renders during typing
    - _Requirements: 2.6.1, 2.6.2_

- [ ] 12. Final checkpoint and integration testing
  - [ ]\* 12.1 Write integration tests for complete workflow
    - Test admin can create and save banner
    - Test banner appears on dashboard after save
    - Test real-time updates work
    - Test banner can be closed by user
    - _Requirements: 2.1.1, 2.1.4, 2.2.1, 2.2.2, 2.5.3_
  - [ ]\* 12.2 Write property test for real-time update broadcast
    - **Property 7: Real-time Update Broadcast**
    - **Validates: Requirements 2.5.3**
  - [ ] 12.3 Final checkpoint - Ensure all tests pass
    - Run all unit tests and property tests
    - Verify no console errors
    - Test in multiple browsers
    - Ensure all tests pass, ask the user if questions arise.

## Notes

- Tasks marked with `*` are optional and can be skipped for faster MVP
- Each task references specific requirements for traceability
- Checkpoints ensure incremental validation
- Property tests validate universal correctness properties
- Unit tests validate specific examples and edge cases
- The implementation leverages existing infrastructure (SiteConfig, WebSocket) to minimize new code
- Real-time updates use the existing WebSocket service
- All styling uses Tailwind CSS with inline styles for user-customizable properties
